\documentclass[journal,12pt,twocolumn]{IEEEtran}

\usepackage{setspace}
\usepackage{gensymb}
\singlespacing
\usepackage[cmex10]{amsmath}
\usepackage{tcolorbox}
\usepackage{amsthm}

\usepackage{mathrsfs}
\usepackage{txfonts}
\usepackage{stfloats}
\usepackage{bm}
\usepackage{cite}
\usepackage{cases}
\usepackage{subfig}

\usepackage{longtable}
\usepackage{multirow}

\usepackage{enumitem}
\usepackage{mathtools}
\usepackage{steinmetz}
\usepackage{tikz}
\usepackage{circuitikz}
\usepackage{verbatim}
\usepackage{tfrupee}
\usepackage[breaklinks=true]{hyperref}
\usepackage{graphicx}
\usepackage{tkz-euclide}

\usetikzlibrary{calc,math}
\usepackage{listings}
    \usepackage{color}                                            %%
    \usepackage{array}                                            %%
    \usepackage{longtable}                                        %%
    \usepackage{calc}                                             %%
    \usepackage{multirow}                                         %%
    \usepackage{hhline}                                           %%
    \usepackage{ifthen}                                           %%
    \usepackage{lscape}     
\usepackage{multicol}
\usepackage{chngcntr}

\DeclareMathOperator*{\Res}{Res}

\renewcommand\thesection{\arabic{section}}
\renewcommand\thesubsection{\thesection.\arabic{subsection}}
\renewcommand\thesubsubsection{\thesubsection.\arabic{subsubsection}}

\renewcommand\thesectiondis{\arabic{section}}
\renewcommand\thesubsectiondis{\thesectiondis.\arabic{subsection}}
\renewcommand\thesubsubsectiondis{\thesubsectiondis.\arabic{subsubsection}}


\hyphenation{op-tical net-works semi-conduc-tor}
\def\inputGnumericTable{}                                 %%

\lstset{
%language=C,
frame=single, 
breaklines=true,
columns=fullflexible
}
\begin{document}


\newtheorem{theorem}{Theorem}[section]
\newtheorem{problem}{Problem}
\newtheorem{proposition}{Proposition}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}[theorem]{Corollary}
\newtheorem{example}{Example}[section]
\newtheorem{definition}[problem]{Definition}

\newcommand{\BEQA}{\begin{eqnarray}}
\newcommand{\EEQA}{\end{eqnarray}}
\newcommand{\define}{\stackrel{\triangle}{=}}
\bibliographystyle{IEEEtran}
\raggedbottom
\setlength{\parindent}{0pt}
\providecommand{\mbf}{\mathbf}
\providecommand{\pr}[1]{\ensuremath{\Pr\left(#1\right)}}
\providecommand{\qfunc}[1]{\ensuremath{Q\left(#1\right)}}
\providecommand{\sbrak}[1]{\ensuremath{{}\left[#1\right]}}
\providecommand{\lsbrak}[1]{\ensuremath{{}\left[#1\right.}}
\providecommand{\rsbrak}[1]{\ensuremath{{}\left.#1\right]}}
\providecommand{\brak}[1]{\ensuremath{\left(#1\right)}}
\providecommand{\lbrak}[1]{\ensuremath{\left(#1\right.}}
\providecommand{\rbrak}[1]{\ensuremath{\left.#1\right)}}
\providecommand{\cbrak}[1]{\ensuremath{\left\{#1\right\}}}
\providecommand{\lcbrak}[1]{\ensuremath{\left\{#1\right.}}
\providecommand{\rcbrak}[1]{\ensuremath{\left.#1\right\}}}
\theoremstyle{remark}
\newtheorem{rem}{Remark}
\newcommand{\sgn}{\mathop{\mathrm{sgn}}}
% \providecommand{\abs}[1]{\left\vert#1\right\vert}
% \providecommand{\res}[1]{\Res\displaylimits_{#1}} 
% \providecommand{\norm}[1]{\left\lVert#1\right\rVert}
% %\providecommand{\norm}[1]{\lVert#1\rVert}
% \providecommand{\mtx}[1]{\mathbf{#1}}
% \providecommand{\mean}[1]{E\left[ #1 \right]}
\providecommand{\fourier}{\overset{\mathcal{F}}{ \rightleftharpoons}}
%\providecommand{\hilbert}{\overset{\mathcal{H}}{ \rightleftharpoons}}
\providecommand{\system}{\overset{\mathcal{H}}{ \longleftrightarrow}}
	%\newcommand{\solution}[2]{\textbf{Solution:}{#1}}
\newcommand{\solution}{\noindent \textbf{Solution: }}
\newcommand{\cosec}{\,\text{cosec}\,}
\providecommand{\dec}[2]{\ensuremath{\overset{#1}{\underset{#2}{\gtrless}}}}
\newcommand{\myvec}[1]{\ensuremath{\begin{pmatrix}#1\end{pmatrix}}}
\newcommand{\mydet}[1]{\ensuremath{\begin{vmatrix}#1\end{vmatrix}}}
\numberwithin{equation}{subsection}
\makeatletter
\@addtoreset{figure}{problem}
\makeatother
\let\StandardTheFigure\thefigure
\let\vec\mathbf
\renewcommand{\thefigure}{\theproblem}
\def\putbox#1#2#3{\makebox[0in][l]{\makebox[#1][l]{}\raisebox{\baselineskip}[0in][0in]{\raisebox{#2}[0in][0in]{#3}}}}
     \def\rightbox#1{\makebox[0in][r]{#1}}
     \def\centbox#1{\makebox[0in]{#1}}
     \def\topbox#1{\raisebox{-\baselineskip}[0in][0in]{#1}}
     \def\midbox#1{\raisebox{-0.5\baselineskip}[0in][0in]{#1}}
\vspace{3cm}
\title{Assignment 1}
\author{C Shruti - EE18BTECH11006}
\maketitle
\newpage
\bigskip
\renewcommand{\thefigure}{\theenumi}
\renewcommand{\thetable}{\theenumi}
Download all files from 
%
\begin{lstlisting}
https://github.com/shruti-chepuri/C-DS/tree/main/Assignment-1
\end{lstlisting}
\section{Problem}
(Q 12) Consider the following intermediate program in three address code
\begin{tcolorbox}
p  = a - b \\
q = p * c \\
p = u * v \\
q = p + q \\
\end{tcolorbox}
Which one of the following corresponds to a static single assignment from the above code?
\section{Solution}
\textbf{Answer:} 
\newline
Static single assignment form is a property of an intermediate representation (IR), which requires that each variable be assigned exactly once, and every variable be defined before it is used. Existing variables in the original IR are split into versions, new variables typically indicated by the original name with a subscript, so that every definition gets its own version.\\

 A compiler can be divided into two parts : the front end (analysis part) and the back end (synthesis part). The intermediate code comes in between these two parts. The front end after preforming lexical, syntax and semantic analysis produces the intermediate code which is consumed or used or fed into the back end for producing the target code or machine code. \\
 
 The front end is language specific and the back end is machine specific. In other words the front end of a C compiler is same in two machines but the back end might be different because of the difference in the architecture and instruction set of the machines. \\
 
 \textbf{Static Single Assignment form (SSA form)} \\
According to Static Single Assignment: 
\begin{itemize}
    \item A variable cannot be used more than once in the LHS.
    \item A variable should be initialized atmost once.
\end{itemize}

Now keeping in mind the above two rules we have, let us look at the options given: \\
A) 
\begin{tcolorbox}[colback=white]
$p_{1}  = a - b \\
q_{1}  = p_1*c$ \\
$p_{1}$  = u*v // $p_{1}$ as already been used once in the LHS \\ 
$q_{1}  = p_{2} + q_{1}$ // $q_{1}$ has already been assigned once before \\ 
\end{tcolorbox}
This code violates condition 1 as $p_1$ has been assigned more than once. \\
B)
\begin{tcolorbox}[colback=white]
$p_{3}  = a - b$ \\
$q_{4}  = p_3*c$ \\
$p_{4}$  = u*v // $p_{3}$ as already been used once in the LHS so we introduce $p_4$ \\ 
$q_{5}  = p_{3} + q_{4}$ // $q_{1}$ has already been used once before hence $q_5$\\ 
\end{tcolorbox}
Option B satisfies all the rules of SSA. \\
C)
\begin{tcolorbox}[colback=white]
$p_{1}  = a - b \\
q_{1}  = p_2*c$ // $p_2$ does not exist \\
$p_{3}  = u*v  \\
q_{2}  = p_{4} + q_{3}$ // $p_4$ and $q_3$ do not exist\\
\end{tcolorbox}
Option C is invalid since $p_2,p_4,q_3$ are not initialized anywhere. \\
D)
\begin{tcolorbox}[colback=white]
$p_{1}  = a - b \\
q_{1}  = p*c$ \\
$p_{2}  = u*v  \\
q_{2}  = p + q$ \\
\end{tcolorbox}
This code is invalid as well since in the original intermediate program, q is sum of the modified variables p and q(they are modified in instructions 1-3), but here $q_2$ is written as a sum of the original p and q values and not the modified values( i.e. $p_2 + q_1$). \\
Thus the SSA form is 
\begin{tcolorbox}
$p_{3}  = a - b \\
q_{4}  = p_3*c$ \\
$p_{4}$  = u*v \\ 
$q_{5}  = p_{3} + q_{4}$
\end{tcolorbox}

\textbf{Advantages of using SSA form:} \\
Using the SSA opens a bunch of opportunities for compiler optimisations like dead code elimination, strength reduction, register allocation, etc 
\end{document}
